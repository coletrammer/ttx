<!-- HTML header for doxygen 1.13.2-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=11" />
    <meta name="generator" content="Doxygen 1.13.2" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>ttx: Terminal</title>
    <link href="tabs.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
 <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
 <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
    <!-- ... other metadata & script includes ... -->
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript">
      DoxygenAwesomeDarkModeToggle.init();
    </script>
    <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
    <script type="text/javascript">
      DoxygenAwesomeFragmentCopyButton.init();
    </script>
    <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
    <script type="text/javascript">
      DoxygenAwesomeParagraphLink.init();
    </script>
  </head>
  <body>
      <div id="top">
        <!-- do not remove this div, it is closed by doxygen! -->
        <div id="titlearea">
          <table cellspacing="0" cellpadding="0">
            <tbody>
              <tr id="projectrow">
                <td id="projectalign">
                  <div id="projectname">
                    ttx<span id="projectnumber">&#160;0.1.0</span
                    >
                  </div>
                </td>
              </tr>
            </tbody>
          </table>
        </div>
        <!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md_docs_2pages_2terminal.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Terminal</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md44"></a></p>
<p>Terminal is modelled as a grid of cells. In a naive implementation, each cell has its own graphics attributes and text. However, in practice, this data model breaks down because of a number of requirements around handling unicode text and certain terminal features.</p>
<h1><a class="anchor" id="autotoc_md45"></a>
Terminal Features</h1>
<ol type="1">
<li>Graphics Rendition (CSI m) - Each individual cell has its own graphics rendition.</li>
</ol>
<ol type="1">
<li>Hyperlinks (OSC 8) - Each individual cell may have an associated hyperlink.</li>
</ol>
<ol type="1">
<li>Text - Each cell has some associated text.<ol type="a">
<li>Because of Unicode zero-width characters, a single cell can consist of multiple code points.</li>
</ol>
<ol type="a">
<li>Certain code points have a width of 2, and thus occupy two cell.</li>
</ol>
<ol type="a">
<li>Terminals usually measure text width naively, but can also use grapheme clustering to determine width (DECSET 2027)</li>
</ol>
<ol type="a">
<li>Applications can specify arbitrary text width via text sizing protocol (OSC 66)</li>
</ol>
<ol type="a">
<li>Old terminal extensions allow specifying double width lines (DECDWL)</li>
</ol>
</li>
</ol>
<ol type="1">
<li>Cell height considerations - Applications can request cells to have logical height &gt; 1<ol type="a">
<li>Text sizing protocol allows specifying up to 7 cells in height (OSC 66), as well as fractional scaling attributes</li>
</ol>
<ol type="a">
<li>Old termination extension for double height line (DECDHL)</li>
</ol>
</li>
</ol>
<ol type="1">
<li>Images - certain protocols enable terminal images<ol type="a">
<li>Kitty image protocol (APC G) allows placement of images referencing cells indirectly, or directly via the passthrough mode</li>
</ol>
<ol type="a">
<li>Sixels are probably storing data within cells</li>
</ol>
<ol type="a">
<li>Iterm image protocol places image indirectly</li>
</ol>
</li>
</ol>
<ol type="1">
<li>Random OSCs - these either associate arbitrary metadata with the terminal or request some sort of UI action<ol type="a">
<li>Window icon/name (OSC 0,1,2) - functionally just modify an attribute of the terminal</li>
</ol>
<ol type="a">
<li>Working directory (OSC 7) - this is just setting an attribute, although it is useful for controlling the initial CWD in new panes</li>
</ol>
<ol type="a">
<li>Clipboard (OSC 52) - this needs to be passed through to the outer application</li>
</ol>
<ol type="a">
<li>Shell prompt regions (OSC 133) - this is metadata associated with the terminal</li>
</ol>
<ol type="a">
<li>Desktop notifications (OSC 9,99) - pass through to outer application</li>
</ol>
<ol type="a">
<li>Color scheme information (OSC 4,10,11) - probably metadata associated with the terminal, maybe this should be global across all panes.</li>
</ol>
</li>
</ol>
<h1><a class="anchor" id="autotoc_md46"></a>
Terminal Operations</h1>
<p>Some operations are controlled by the process running in the terminal (escape sequences), while others are controlled by the user (scrolling).</p>
<ol type="1">
<li>Editing text in cell (this is obvious and the most common operation)</li>
</ol>
<ol type="1">
<li>Setting graphics rendition of a cell</li>
</ol>
<ol type="1">
<li>Cursor movement</li>
</ol>
<ol type="1">
<li>Inserting/deleting characters (this can be done via escape sequences) - this shifts over the contents of cells on a line</li>
</ol>
<ol type="1">
<li>Inserting/Deleting a line (this can be done via escape sequences) - this is like scrolling except only affects visible cells</li>
</ol>
<ol type="1">
<li>Scrolling - this conceptually doesn't change the active contents of terminal cells, but does affect what gets rendered</li>
</ol>
<ol type="1">
<li>Resizing - when modifying the horizontal size we want to reflow text (lines which overflowed may become a single line)</li>
</ol>
<h1><a class="anchor" id="autotoc_md47"></a>
Data Structure</h1>
<p>Because attributes like hyperlinks and the graphics rendition will be shared across cells, it makes sense to refer to these indirectly in a cell (if we store cells at all). This means there would be map from id to value and each cell would have an id for each of these attributes.</p>
<p>For text, we can store the size of the associated text for each cell. This allows for arbitrary width cells with an arbitrary amount of text, while still be reasonably efficient. The cursor will cache the actual text offset for each cell, which makes normal text operations efficient. By storing the width, we don't need to update every cell when performing certain operations (specifically overwriting a cell with new text). However, this approach is non-ideal when implementing insert/delete lines when a horizontal margin is present (but this is super rare).</p>
<p>For multi-line cells, they would have no corresponding text but will have some attribute set to indicate the cell's true information is stored elsewhere.</p>
<p>Cells also need damage tracking as an individual flag for optimizations when rendering.</p>
<h1><a class="anchor" id="autotoc_md48"></a>
Scroll Back</h1>
<p>Because scroll back cells are read-only, and the amount of scroll back the user may want is very large, a different data structure should be used for scroll back. In particular, the 16 bit integers used for the modifiable screen contents won't work at all when the scroll back becomes large enough. Additionally, most of the cells in scroll back will be completely empty, so it makes sense to optimize them out.</p>
<p>To handle the large size restriction, we can either use cells with larger index types, and "global" maps for all indirect metadata, or split these up into independent chunks/blocks/pages. The latter approach is clearly more efficient but is more complicated, especially because hyperlinks and multi cell info can span multiple terminal rows. This can be handled by either choosing boundaries which do not induce this behavior (and splitting hyperlink / drop multi cells in pathological cases), or with special markers which indicate to look at a separate block. Splitting hyperlinks is reasonable, but dropping multi cells is non-ideal (although realistically multi cells are going to be used by full screen applications with no scroll back so its not super important.</p>
<p>The other important operation with the scroll back is reflowing lines which we auto-wrapped. This is very useful functionality, but has important performance constraints, because the scroll back buffer can be potentially very large. This is especially problematic in cases where there is an extremely large line (1 million characters) when using a chunk based approach, since the entire line cannot fit in scroll back. Calling <code>cat</code> on a large file with no newline needs to not hang the terminal. This implies that the scroll back limit should not be measured in lines ( which makes sense anyway because lines have no fixed meaning when we reflow text dynamically).</p>
<p>For this reason, we cannot consolidate logical lines into a single line for the purpose of scroll back. However, handling the extremely large line case is still tricky (unless we enforce a maximum line length).</p>
<p>Multi cells with a height greater than 0 are also very difficult to deal with when reflowing lines, when the cells have mixed height.</p>
<h1><a class="anchor" id="autotoc_md49"></a>
Multi Cells</h1>
<p>Combined cells come in 2 forms: wide characters as determined by the grapheme cluster width, and explicitly sized text specified by the kitty text-sizing protocol. Although wide characters represent an extreme subset of the text-sizing protocol, wide characters are more common and may deserve special optimizations.</p>
<p>To represent combined cells, it likely makes the most sense to store the associated text and graphics rendition in the top-left cell. This is useful because it lets us re-use several fields, and maps naturally when rendering cells. Every other "cell" linked to the primary cell can be ignored.</p>
<p>However, blank cells cannot be ignored when modifying terminal contents. In particular, erasing or overwriting a single cell which is part of a combined cell clears the whole mulit-cell. This gives us to ways of handling this operation: eager clearing or lazy clearing.</p>
<h2><a class="anchor" id="autotoc_md50"></a>
Eager Clearing</h2>
<p>In this model, when we "clear" a cell which is part of a multi-cell, we need to find the all other joined cells and erase those too. This is somewhat inefficient and often redundant, as depending on the mutation, we're going to erase those other cells next (think something clearing the current line).</p>
<h2><a class="anchor" id="autotoc_md51"></a>
Lazy Clearing</h2>
<p>In this model, clearing a part of a multi-cell simply sets a flag on the shared metadata indicating the cell is no longer valid. When rendering, we can check this flag and treat the cell as blank if this flag is set. To properly handle background character erase, we'd need to store an associated background color on the multicell object. Additionally, we can longer share multi-cell metadata objects between "equivalent" multi-cells. This is especially bad when considering text consisting of all width 2 characters. We'd effectively need 1.5 as many objects as we would if we used the eager approach.</p>
<h2><a class="anchor" id="autotoc_md52"></a>
Solution</h2>
<p>Given these constraints, it makes the most sense to lazily clear multicells with height &gt; 1 and eagerly clear cells with height = 1. Almost all terminal mutations are implemented on a per-row basis, and so will be able to eagerly clear multicells based by checking the boundaries of the operation. For the common case of width=2, we'll still give the cell a multicell id, but it will have a fast path for lookup.</p>
<p>To determine which cell of a multicell is "primary", we'll need a 2 bit flags per cell. The primary cell will have both bits set, while the top-most and left-most cells will have only 1 of the bits set. Finding the primary cell can be done by iterating up and to the left looking for these flags. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="md_docs_2pages_2architecture__docs.html">Architecture Docs</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
